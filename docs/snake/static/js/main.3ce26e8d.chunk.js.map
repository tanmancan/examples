{"version":3,"sources":["types/constants.ts","Ui.ts","Collision.ts","Food.ts","Grid.ts","Snake.ts","GameController.ts","demo/App.tsx","demo/serviceWorker.ts","index.tsx"],"names":["KeyCode","EventTypes","OptionTypes","Collision","callback","source","bounds","this","joinedBounds","map","uniqueBounds","Set","Array","from","addBounds","sourceCollision","hasCollision","forEach","collision","sourceBounds","getBounds","some","bound","indexOf","Food","width","height","gridSize","canvas","ctx","eatCount","foodPosition","getRandomPosition","x","y","eaten","bind","setUp","document","createElement","getContext","style","position","zIndex","fillStyle","draw","remove","getCtx","currentX","currentY","clearRect","newX","newY","fillRect","replaceBounds","widthSegments","heightSegments","posX","Math","floor","random","posY","Grid","translate","strokeStyle","collide","wallBounds","getWallBounds","xPos","push","yPos","beginPath","gridLineX","moveTo","lineTo","gridLineY","stroke","closePath","Snake","timestamp","paused","distanceFactor","timeFactor","vector","body","bodyLength","bodySegmentSize","headCollision","tailCollision","deadSnake","window","addEventListener","KEYDOWN","background","slice","removeEventListener","checkBounds","eat","die","e","type","keyDownHandler","code","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","removedSegment","newPos","getNewHeadPos","length","pop","unshift","checkInternalCollision","headX","headY","exp","isSnakeDead","delayCheck","move","removedX","removedY","bodyX","bodyY","Ui","score","highScore","gameOver","debugData","lastTimestamp","gameCount","options","boxChecked","Path2D","label","DEBUG","state","setDefaultTextStyles","preRenderOptions","localStorage","getItem","Number","MOUSEMOVE","handleMouseMove","handleOptionHover","MOUSEDOWN","handleOptionClick","offsetX","offsetY","option","optionIsPointInPath","inPath","cursor","path","clientWidth","clientHeight","widthModifier","heightModifier","adjustedX","adjustedY","isPointInPath","setItem","font","textAlign","textBaseline","key","filter","opt","originX","originY","idx","measure","measureText","hitBox","rect","checkBox","fill","globalAlpha","fillText","renderOverlayBackground","setOverlayTextStyles","renderOptions","debugText","frameLengthMs","index","time","clear","getOptionValue","renderDebugScreen","renderGameOverScreen","renderPauseScreen","renderScoreScreen","GameController","board","gridWidth","gridHeight","gameWidth","gameHeight","snake","snakeCanvas","grid","gridCanvas","food","foodCanvas","ui","uiCanvas","rafId","querySelector","getCanvas","appendChild","setDebugData","tearDown","cancelAnimationFrame","KEYUP","handleKeyup","ENTER","run","getEatCount","setScore","setGameOver","snakeCollision","getCollision","foodCollision","wallCollision","requestAnimationFrame","App","useEffect","create","id","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.3ce26e8d.chunk.js","sourcesContent":["export enum KeyCode {\n  ARROW_LEFT = \"ArrowLeft\",\n  ARROW_RIGHT = \"ArrowRight\",\n  ARROW_UP = \"ArrowUp\",\n  ARROW_DOWN = \"ArrowDown\",\n  ENTER = \"Enter\",\n}\n\nexport enum EventTypes {\n  KEYUP = \"keyup\",\n  KEYDOWN = \"keydown\",\n  MOUSEMOVE = \"mousemove\",\n  MOUSEDOWN = \"mousedown\",\n}\n","import { Drawable } from \"./types/drawable\";\nimport { EventTypes } from \"./types/constants\";\n\nconst HIGH_SCORE_KEY = \"canvas-snake-hs\";\n\nconst OVERLAY_COLOR = \"black\";\nconst OVERLAY_TEXT_COLOR = \"white\";\nconst OVERLAY_TRANSPARENCY = 0.75;\n\nenum OptionTypes {\n  DEBUG = \"DEBUG\",\n}\n\ninterface OptionsBounds {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\ninterface GameOptions {\n  label: string;\n  state: boolean;\n  type: OptionTypes;\n  bounds?: OptionsBounds;\n  path?: Path2D;\n}\n\nexport class Ui implements Drawable {\n  canvas?: HTMLCanvasElement | null = null;\n  ctx: CanvasRenderingContext2D | null = null;\n  width: number;\n  height: number;\n  timestamp?: number;\n  gridSize: number;\n\n  private score: number = 0;\n  private highScore: number = 0;\n  private gameOver: boolean = false;\n\n  private debugData = {\n    x: 0,\n    y: 0,\n    lastTimestamp: 0,\n    gameCount: 1,\n  };\n\n  private options: GameOptions[];\n\n  private boxChecked = new Path2D();\n\n  constructor(width: number, height: number, gridSize: number) {\n    this.width = width;\n    this.height = height;\n    this.gridSize = gridSize;\n    this.options = [\n      {\n        label: \"Show Debug Info\",\n        type: OptionTypes.DEBUG,\n        state: false,\n      },\n    ];\n    this.setUp();\n  }\n\n  setUp() {\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas?.getContext(\"2d\") as CanvasRenderingContext2D;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.zIndex = \"3\";\n\n    this.canvas.addEventListener(\"mousemove\", this);\n    this.canvas.addEventListener(\"mousedown\", this);\n    this.setDefaultTextStyles();\n    this.preRenderOptions();\n\n    this.highScore = window.localStorage.getItem(HIGH_SCORE_KEY)\n      ? Number(window.localStorage.getItem(HIGH_SCORE_KEY))\n      : 0;\n    this.draw();\n  }\n\n  tearDown() {\n    this.canvas?.removeEventListener(\"mousemove\", this);\n    this.canvas?.removeEventListener(\"mousedown\", this);\n    this.canvas?.remove();\n    this.canvas = null;\n    this.ctx = null;\n  }\n\n  handleEvent(e: Event) {\n    switch (e.type) {\n      case EventTypes.MOUSEMOVE:\n        this.handleMouseMove(e as MouseEvent);\n        this.handleOptionHover(e as MouseEvent);\n        break;\n      case EventTypes.MOUSEDOWN:\n        this.handleOptionClick(e as MouseEvent);\n        break;\n    }\n  }\n\n  handleMouseMove(e: MouseEvent) {\n    this.debugData.x = e.offsetX;\n    this.debugData.y = e.offsetY;\n  }\n\n  handleOptionClick(e: MouseEvent) {\n    this.options.forEach((option) => {\n      const inPath = this.optionIsPointInPath(e, option);\n      if (inPath) {\n        option.state = !option.state;\n      }\n    });\n  }\n\n  handleOptionHover(e: MouseEvent) {\n    this.options.forEach((option) => {\n      const inPath = this.optionIsPointInPath(e, option);\n      if (this.canvas) {\n        if (inPath) {\n          this.canvas.style.cursor = \"pointer\";\n        } else {\n          this.canvas.style.cursor = \"default\";\n        }\n      }\n    });\n  }\n\n  optionIsPointInPath(e: MouseEvent, option: GameOptions): boolean {\n    const ctx = this.getCtx();\n    let inPath = false;\n    if (option.path && this.canvas) {\n      const { clientWidth, clientHeight } = this.canvas;\n      const widthModifier = this.width / clientWidth;\n      const heightModifier = this.height / clientHeight;\n      const adjustedX = e.offsetX * widthModifier;\n      const adjustedY = e.offsetY * heightModifier;\n\n      inPath = ctx.isPointInPath(option.path, adjustedX, adjustedY);\n    }\n\n    return inPath;\n  }\n\n  getCanvas(): HTMLCanvasElement {\n    return (this.canvas as unknown) as HTMLCanvasElement;\n  }\n\n  getCtx(): CanvasRenderingContext2D {\n    return (this.ctx as unknown) as CanvasRenderingContext2D;\n  }\n\n  setScore(score: number) {\n    this.score = score;\n    if (this.score > this.highScore) {\n      this.highScore = this.score;\n      window.localStorage.setItem(HIGH_SCORE_KEY, `${this.highScore}`);\n    }\n  }\n\n  setGameOver(gameOver: boolean) {\n    this.gameOver = gameOver;\n  }\n\n  setDefaultTextStyles() {\n    const ctx = this.getCtx();\n    ctx.fillStyle = \"black\";\n    ctx.font = `700 ${this.gridSize}px monospace`;\n    ctx.textAlign = \"right\";\n    ctx.textBaseline = \"top\";\n  }\n\n  setOverlayTextStyles() {\n    const ctx = this.getCtx();\n    ctx.fillStyle = OVERLAY_TEXT_COLOR;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n  }\n\n  getOptionValue(key: OptionTypes) {\n    const option = this.options.filter((opt) => opt.type === key);\n    return option[0].state;\n  }\n\n  preRenderOptions() {\n    const ctx = this.getCtx();\n    const originX = this.width / 2;\n    const originY = this.height / 2 - this.gridSize;\n\n    this.options.forEach((option, idx) => {\n      const measure = ctx.measureText(option.label);\n      option.bounds = {\n        x: originX - measure.width / 2,\n        y: originY + idx * this.gridSize,\n        width: measure.width,\n        height: this.gridSize,\n      };\n      const hitBox = new Path2D();\n      hitBox.rect(\n        option.bounds.x,\n        option.bounds.y,\n        option.bounds.width,\n        option.bounds.height\n      );\n      const checkBox = new Path2D(hitBox);\n      checkBox.rect(\n        option.bounds.x - this.gridSize * 1.5,\n        option.bounds.y,\n        this.gridSize,\n        this.gridSize\n      );\n      option.path = checkBox;\n    });\n  }\n\n  renderOptions() {\n    const ctx = this.getCtx();\n    this.options.forEach((option) => {\n      ctx.stroke(this.boxChecked);\n      if (option.path) ctx.fill(option.path);\n      if (option.bounds) {\n        const { x, y, width, height } = option.bounds;\n\n        ctx.clearRect(x, y, width, height);\n        ctx.clearRect(\n          x - this.gridSize * 1.5 + 5,\n          y + 5,\n          this.gridSize - 10,\n          this.gridSize - 10\n        );\n        ctx.globalAlpha = OVERLAY_TRANSPARENCY;\n        ctx.fillStyle = OVERLAY_COLOR;\n        ctx.fillRect(x, y, width, height);\n        ctx.fillRect(\n          x - this.gridSize * 1.5 + 5,\n          y + 5,\n          this.gridSize - 10,\n          this.gridSize - 10\n        );\n        ctx.globalAlpha = 1.0;\n        ctx.fillStyle = OVERLAY_TEXT_COLOR;\n\n        if (option.state) {\n          ctx.fillStyle = \"green\";\n          ctx.fillRect(\n            x - this.gridSize * 1.5 + 5,\n            y + 5,\n            this.gridSize - 10,\n            this.gridSize - 10\n          );\n          ctx.fillStyle = OVERLAY_TEXT_COLOR;\n        }\n\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        ctx.fillText(option.label, x + width / 2, y + this.gridSize / 2);\n      }\n    });\n\n    this.setDefaultTextStyles();\n  }\n\n  renderOverlayBackground() {\n    const ctx = this.getCtx();\n    ctx.globalAlpha = OVERLAY_TRANSPARENCY;\n    ctx.fillStyle = OVERLAY_COLOR;\n    ctx.fillRect(0, 0, this.width, this.height);\n    ctx.globalAlpha = 1.0;\n  }\n\n  renderPauseScreen() {\n    const ctx = this.getCtx();\n\n    this.renderOverlayBackground();\n    this.setOverlayTextStyles();\n\n    ctx.fillText(\"Paused\", this.width / 2, this.height / 2 - this.gridSize * 4);\n\n    this.renderOptions();\n  }\n\n  renderGameOverScreen() {\n    const ctx = this.getCtx();\n    this.renderOverlayBackground();\n    this.setOverlayTextStyles();\n    ctx.fillText(\n      `Game Over`,\n      this.width / 2,\n      this.height / 2 - this.gridSize * 4\n    );\n    ctx.fillText(\n      `Score ${this.score}`,\n      this.width / 2,\n      this.height / 2 - this.gridSize * 2\n    );\n    ctx.fillText(\n      `High score ${this.highScore}`,\n      this.width / 2,\n      this.height / 2 - this.gridSize\n    );\n    ctx.fillText(\n      `Press Enter to`,\n      this.width / 2,\n      this.height / 2 + this.gridSize\n    );\n    ctx.fillText(\n      `Start a New Game`,\n      this.width / 2,\n      this.height / 2 + this.gridSize * 2\n    );\n    ctx.fillText(\n      `Game no. ${this.debugData.gameCount}`,\n      this.width / 2,\n      this.height / 2 + this.gridSize * 4\n    );\n  }\n\n  setDebugData(debugData: any) {\n    this.debugData = {\n      ...this.debugData,\n      ...debugData,\n    };\n  }\n\n  renderDebugScreen(timestamp?: number) {\n    const debugText = [];\n\n    debugText.push(`Mouse: ${this.debugData.x}, ${this.debugData.y}`);\n    if (timestamp) {\n      const frameLengthMs = timestamp - this.debugData.lastTimestamp;\n      debugText.push(`FPS: ${Math.floor(1000 / frameLengthMs)}`);\n      this.debugData.lastTimestamp = timestamp;\n    }\n    debugText.push(`Game count: ${this.debugData.gameCount}`);\n\n    for (let index = 0; index < debugText.length; index++) {\n      this.ctx?.fillText(\n        `${debugText[index]}`,\n        this.width - this.gridSize,\n        this.height - this.gridSize * (index + 1)\n      );\n    }\n  }\n\n  renderScoreScreen() {\n    const ctx = this.getCtx();\n    this.setDefaultTextStyles();\n    ctx.fillText(`${this.score}`, this.width - this.gridSize, this.gridSize);\n  }\n\n  clear() {\n    const ctx = this.getCtx();\n    ctx.clearRect(0, 0, this.width, this.height);\n  }\n\n  draw(time?: number, paused?: boolean) {\n    this.clear();\n\n    const debug = this.getOptionValue(OptionTypes.DEBUG);\n    if (debug) {\n      this.renderDebugScreen(time);\n    }\n\n    if (this.gameOver) {\n      this.renderGameOverScreen();\n      return;\n    }\n\n    if (paused) {\n      this.renderPauseScreen();\n      return;\n    }\n\n    this.renderScoreScreen();\n  }\n}\n","/**\n * Represents a position in the canvas grid: x, y\n */\nexport type CollisionPosition = [number, number];\n\n/**\n * A callback that is called when a collision has occurred. Should be\n * passed the source property of the Collision object being checked.\n */\nexport type CollisionCallback = (source: string) => any;\n\n/**\n * Interface describing a collision between two objects.\n * Objects are represented by a list of positions in the canvas grid.\n * If any of the positions in two bounds intersect, then a collision will occur,\n * and a callback will be called for each object.\n */\nexport interface CollisionBounds {\n  /**\n   * Represents a list of canvas grid position, by their\n   * concatenated x and y values.\n   * Example: [10, 25] = \"1025\"\n   */\n  bounds: string[];\n  /**\n   * Callback that will be called if a collision has occurred\n   * with another Collision object.\n   */\n  callback: CollisionCallback;\n  /**\n   * Add a grid position as a bound. Adds to any existing bounds.\n   */\n  addBounds: (bounds: CollisionPosition[]) => void;\n  /**\n   * Add a grid position as a bound. Replaces any existing bounds.\n   */\n  replaceBounds: (bounds: CollisionPosition[]) => void;\n  /**\n   * Get a list of bounds for this collision object.\n   */\n  getBounds: () => string[];\n  /**\n   * Check collision against another collision object.\n   * If a collision occurs, this should call the callback function\n   * for both collision object.\n   */\n  checkBounds: (sourceCollision: Collision[]) => void;\n}\n\nexport interface HasCollision {\n  collision: Collision | null;\n  setCollision: (collision: Collision) => void;\n  getCollision: () => Collision;\n}\n\nexport class Collision implements CollisionBounds {\n  bounds: string[] = [];\n  callback: CollisionCallback;\n  source: string;\n\n  constructor(callback: CollisionCallback, source: string) {\n    this.callback = callback;\n    this.source = source;\n  }\n\n  addBounds(bounds: CollisionPosition[]) {\n    const joinedBounds = bounds.map(([x, y]) => \"\" + x + y);\n    const uniqueBounds = new Set([...this.bounds, ...joinedBounds]);\n    this.bounds = Array.from(uniqueBounds);\n  }\n\n  replaceBounds(bounds: CollisionPosition[]) {\n    this.bounds = [];\n    this.addBounds(bounds);\n  }\n\n  getBounds() {\n    return this.bounds;\n  }\n\n  checkBounds(sourceCollision: Collision[]) {\n    let hasCollision;\n    if (hasCollision) return;\n    sourceCollision.forEach((collision) => {\n      const sourceBounds = collision.getBounds();\n      hasCollision = sourceBounds.some(\n        (bound) => this.bounds.indexOf(bound) !== -1\n      );\n      if (hasCollision) {\n        collision.callback(this.source);\n        this.callback(collision.source);\n        return;\n      }\n      hasCollision = false;\n    });\n  }\n}\n","import { Drawable } from \"./types/drawable\";\nimport { HasCollision, Collision } from \"./Collision\";\n\nexport const FOOD_COLLISION = \"FOOD\";\n\nexport class Food implements Drawable, HasCollision {\n  canvas?: HTMLCanvasElement | null = null;\n  ctx: CanvasRenderingContext2D | null = null;\n  width: number;\n  height: number;\n  gridSize: number;\n  collision: Collision;\n\n  private eatCount: number = 0;\n  private foodPosition: number[];\n\n  constructor(width: number, height: number, gridSize: number) {\n    this.width = width;\n    this.height = height;\n    this.gridSize = gridSize;\n    const [x, y] = this.getRandomPosition();\n    this.foodPosition = [x, y];\n\n    this.collision = new Collision(this.eaten.bind(this), FOOD_COLLISION);\n    this.collision.addBounds([[x, y]]);\n    this.setUp();\n  }\n\n  setUp() {\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.zIndex = \"0\";\n    this.ctx.fillStyle = \"red\";\n    this.draw();\n  }\n\n  tearDown() {\n    this.canvas?.remove();\n    this.canvas = null;\n  }\n\n  setCollision(collision: Collision) {\n    this.collision = collision;\n    this.ctx = null;\n  }\n\n  getCollision() {\n    return this.collision;\n  }\n\n  eaten() {\n    const ctx = this.getCtx();\n    const [currentX, currentY] = this.foodPosition;\n    ctx.clearRect(currentX, currentY, this.gridSize, this.gridSize);\n\n    const [newX, newY] = this.getRandomPosition();\n    ctx.fillRect(newX, newY, this.gridSize, this.gridSize);\n    this.foodPosition = [newX, newY];\n    this.collision.replaceBounds([[newX, newY]]);\n\n    this.eatCount += 1;\n  }\n\n  getEatCount() {\n    return this.eatCount;\n  }\n\n  getRandomPosition() {\n    const widthSegments = this.width / this.gridSize;\n    const heightSegments = this.height / this.gridSize;\n    const posX = Math.floor(Math.random() * widthSegments);\n    const posY = Math.floor(Math.random() * heightSegments);\n\n    return [posX * this.gridSize, posY * this.gridSize];\n  }\n\n  getCanvas(): HTMLCanvasElement {\n    return (this.canvas as unknown) as HTMLCanvasElement;\n  }\n\n  getCtx(): CanvasRenderingContext2D {\n    return (this.ctx as unknown) as CanvasRenderingContext2D;\n  }\n\n  draw() {\n    const ctx = this.getCtx();\n    const [currentX, currentY] = this.foodPosition;\n    ctx.fillRect(currentX, currentY, this.gridSize, this.gridSize);\n  }\n}\n","import { Drawable } from \"./types/drawable\";\nimport { Collision, HasCollision } from \"./Collision\";\n\nexport const WALL_COLLISION = \"WALL\";\n\nexport class Grid implements Drawable, HasCollision {\n  canvas?: HTMLCanvasElement | null = null;\n  ctx: CanvasRenderingContext2D | null = null;\n  width: number;\n  height: number;\n  gridSize: number;\n  collision: Collision | null = null;\n\n  constructor(width: number, height: number, gridSize: number) {\n    this.width = width;\n    this.height = height;\n    this.gridSize = gridSize;\n    this.setUp();\n  }\n\n  setUp() {\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.zIndex = \"1\";\n    this.ctx.translate(-0.5, -0.5);\n    this.ctx.strokeStyle = \"white\";\n\n    this.collision = new Collision(this.collide.bind(this), WALL_COLLISION);\n    const wallBounds = this.getWallBounds();\n    this.collision.addBounds(wallBounds);\n\n    this.draw();\n  }\n\n  tearDown() {\n    this.canvas?.remove();\n    this.canvas = null;\n    this.ctx = null;\n    this.collision = null;\n  }\n\n  getWallBounds() {\n    let bounds: [number, number][] = [];\n\n    // Top and bottom wall\n    for (let xPos = -this.gridSize; xPos < this.width; xPos += this.gridSize) {\n      bounds.push([xPos, -this.gridSize]);\n      bounds.push([xPos, this.height]);\n    }\n    // Side walls\n    for (let yPos = -this.gridSize; yPos < this.height; yPos += this.gridSize) {\n      bounds.push([-this.gridSize, yPos]);\n      bounds.push([this.width, yPos]);\n    }\n\n    return bounds;\n  }\n\n  setCollision(collision: Collision) {\n    this.collision = collision;\n  }\n\n  getCollision() {\n    return (this.collision as unknown) as Collision;\n  }\n\n  getCanvas(): HTMLCanvasElement {\n    return (this.canvas as unknown) as HTMLCanvasElement;\n  }\n\n  getCtx(): CanvasRenderingContext2D {\n    return (this.ctx as unknown) as CanvasRenderingContext2D;\n  }\n\n  collide() {}\n\n  draw() {\n    const ctx = this.getCtx();\n    ctx.beginPath();\n    for (\n      let gridLineX = 0;\n      gridLineX < this.height;\n      gridLineX += this.gridSize\n    ) {\n      ctx.moveTo(0, gridLineX);\n      ctx.lineTo(this.width, gridLineX);\n    }\n    for (\n      let gridLineY = 0;\n      gridLineY < this.width;\n      gridLineY += this.gridSize\n    ) {\n      ctx.moveTo(gridLineY, 0);\n      ctx.lineTo(gridLineY, this.height);\n    }\n    ctx.stroke();\n    ctx.closePath();\n  }\n}\n","import { KeyCode, EventTypes } from \"./types/constants\";\nimport { Drawable } from \"./types/drawable\";\nimport { HasCollision, Collision } from \"./Collision\";\nimport { FOOD_COLLISION } from \"./Food\";\nimport { WALL_COLLISION } from \"./Grid\";\n\ntype BodySegment = [number, number];\n\ntype SnakeVector = [number, number];\n\nexport const SNAKE_COLLISION = \"SNAKE\";\n\nconst HEAD_COLLISOIN = \"HEAD\";\nconst TAIL_COLLISION = \"TAIL\";\n\nexport class Snake implements Drawable, HasCollision {\n  canvas?: HTMLCanvasElement | null = null;\n  ctx: CanvasRenderingContext2D | null = null;\n  width: number;\n  height: number;\n  gridSize: number;\n  timestamp?: number;\n  collision: Collision | null = null;\n\n  private paused: boolean = false;\n  private distanceFactor: number;\n  private timeFactor: number = 5.5;\n  private vector: SnakeVector;\n  private body: BodySegment[] = [[0, 0]];\n  private bodyLength = 3;\n  private bodySegmentSize = 10;\n\n  private headCollision: Collision | null = null;\n  private tailCollision: Collision | null = null;\n\n  private deadSnake: boolean = false;\n\n  constructor(width: number, height: number, gridSize: number) {\n    this.width = width;\n    this.height = height;\n    this.gridSize = gridSize;\n    this.distanceFactor = this.gridSize;\n    this.bodySegmentSize = this.gridSize;\n    this.vector = [this.gridSize, 0];\n\n    this.setUp();\n  }\n\n  setUp() {\n    window.addEventListener(EventTypes.KEYDOWN, this);\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.zIndex = \"0\";\n    this.canvas.style.background = \"whitesmoke\";\n    this.ctx.fillStyle = \"green\";\n\n    this.collision = new Collision(this.collide.bind(this), SNAKE_COLLISION);\n    this.collision.addBounds(this.body);\n\n    /**\n     * We will use these to track internal collision between the snake's head and tails.\n     */\n    this.headCollision = new Collision(this.collide.bind(this), HEAD_COLLISOIN);\n    this.tailCollision = new Collision(this.collide.bind(this), TAIL_COLLISION);\n\n    this.headCollision.addBounds([this.body[0]]);\n    this.tailCollision.addBounds(this.body.slice(1));\n  }\n\n  tearDown() {\n    window.removeEventListener(EventTypes.KEYDOWN, this);\n    this.canvas?.remove();\n    this.canvas = null;\n    this.ctx = null;\n    this.collision = null;\n    this.headCollision = null;\n    this.tailCollision = null;\n  }\n\n  checkInternalCollision() {\n    if (this.tailCollision)\n      this.headCollision?.checkBounds([this.tailCollision]);\n  }\n\n  collide(source: string) {\n    switch (source) {\n      case FOOD_COLLISION:\n        this.eat();\n        break;\n      case TAIL_COLLISION:\n      case HEAD_COLLISOIN:\n      case WALL_COLLISION:\n        this.die();\n        break;\n      default:\n        break;\n    }\n  }\n\n  setCollision(collision: Collision) {\n    this.collision = collision;\n  }\n\n  getCollision() {\n    return (this.collision as unknown) as Collision;\n  }\n\n  getCanvas(): HTMLCanvasElement {\n    return (this.canvas as unknown) as HTMLCanvasElement;\n  }\n\n  getCtx(): CanvasRenderingContext2D {\n    return (this.ctx as unknown) as CanvasRenderingContext2D;\n  }\n\n  handleEvent(e: KeyboardEvent) {\n    switch (e.type) {\n      case EventTypes.KEYDOWN:\n        this.keyDownHandler(e);\n        break;\n    }\n  }\n\n  keyDownHandler(e: KeyboardEvent) {\n    if (this.paused) return;\n\n    switch (e.code) {\n      case KeyCode.ARROW_LEFT:\n        this.vector = [-1 * this.distanceFactor, 0];\n        break;\n      case KeyCode.ARROW_RIGHT:\n        this.vector = [this.distanceFactor, 0];\n        break;\n      case KeyCode.ARROW_UP:\n        this.vector = [0, -1 * this.distanceFactor];\n        break;\n      case KeyCode.ARROW_DOWN:\n        this.vector = [0, this.distanceFactor];\n        break;\n    }\n  }\n\n  eat() {\n    this.bodyLength += 1;\n    this.timeFactor -= 0.125;\n  }\n\n  move() {\n    const newPos = this.getNewHeadPos();\n    if (!newPos) return;\n\n    let removedSegment: BodySegment | undefined;\n    if ((this.body.length = this.bodyLength)) {\n      removedSegment = this.body.pop();\n    }\n\n    this.body.unshift(newPos);\n\n    this.collision?.replaceBounds(this.body);\n    this.headCollision?.replaceBounds([this.body[0]]);\n    this.tailCollision?.replaceBounds(this.body.slice(1));\n\n    this.checkInternalCollision();\n\n    return removedSegment;\n  }\n\n  getNewHeadPos(): [number, number] | null {\n    const [headX, headY] = this.body[0];\n    const [speedX, speedY] = this.vector;\n\n    return [headX + speedX, headY + speedY];\n  }\n\n  die() {\n    this.deadSnake = true;\n  }\n\n  isSnakeDead() {\n    return this.deadSnake;\n  }\n\n  delayCheck(timestamp?: number): boolean {\n    if (\n      timestamp &&\n      this.timestamp &&\n      timestamp < this.timestamp + Math.exp(this.timeFactor)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  draw(timestamp?: number, paused?: boolean) {\n    const ctx = this.getCtx();\n\n    if (this.isSnakeDead()) return;\n\n    this.paused = (paused as boolean) ?? false;\n    if (paused) {\n      return;\n    }\n\n    if (!this.delayCheck(timestamp)) {\n      const removedSegment = this.move();\n      if (removedSegment) {\n        const [removedX, removedY] = removedSegment;\n        ctx.clearRect(\n          removedX,\n          removedY,\n          this.bodySegmentSize,\n          this.bodySegmentSize\n        );\n      }\n      this.timestamp = timestamp;\n    }\n\n    this.body.forEach(([bodyX, bodyY]) => {\n      ctx.fillRect(bodyX, bodyY, this.bodySegmentSize, this.bodySegmentSize);\n    });\n  }\n}\n","import { Snake } from \"./Snake\";\nimport { Grid } from \"./Grid\";\nimport { Food } from \"./Food\";\nimport { Ui } from \"./Ui\";\nimport { EventTypes, KeyCode } from \"./types/constants\";\n\nexport class GameController {\n  private board: HTMLDivElement | null;\n\n  private readonly gridSize = 40;\n  private readonly gridWidth = 30;\n  private readonly gridHeight = 15;\n  private gameWidth: number;\n  private gameHeight: number;\n\n  private snake: Snake | null = null;\n  private snakeCanvas: HTMLCanvasElement | null = null;\n  private grid: Grid | null = null;\n  private gridCanvas: HTMLCanvasElement | null = null;\n  private food: Food | null = null;\n  private foodCanvas: HTMLCanvasElement | null = null;\n  private ui: Ui | null = null;\n  private uiCanvas: HTMLCanvasElement | null = null;\n\n  private rafId: number = 0;\n  private paused: boolean = true;\n  private gameCount: number = 1;\n\n  private constructor() {\n    this.board = document.querySelector(\"div#board\");\n    this.gameWidth = this.gridSize * this.gridWidth;\n    this.gameHeight = this.gridSize * this.gridHeight;\n    this.setUp();\n  }\n\n  static create() {\n    return new GameController();\n  }\n\n  setUp() {\n    window.addEventListener(\"keyup\", this);\n    this.snake = new Snake(this.gameWidth, this.gameHeight, this.gridSize);\n    this.snakeCanvas = this.snake.getCanvas();\n    this.grid = new Grid(this.gameWidth, this.gameHeight, this.gridSize);\n    this.gridCanvas = this.grid.getCanvas();\n    this.food = new Food(this.gameWidth, this.gameHeight, this.gridSize);\n    this.foodCanvas = this.food.getCanvas();\n    this.ui = new Ui(this.gameWidth, this.gameHeight, this.gridSize);\n    this.uiCanvas = this.ui.getCanvas();\n\n    this.board?.appendChild(this.snakeCanvas);\n    this.board?.appendChild(this.gridCanvas);\n    this.board?.appendChild(this.foodCanvas);\n    this.board?.appendChild(this.uiCanvas);\n\n    this.ui.setDebugData({ gameCount: this.gameCount });\n  }\n\n  tearDown() {\n    window.removeEventListener(\"keyup\", this);\n    this.snake?.tearDown();\n    this.ui?.tearDown();\n    this.food?.tearDown();\n    this.grid?.tearDown();\n\n    this.snakeCanvas?.remove();\n    this.gridCanvas?.remove();\n    this.foodCanvas?.remove();\n    this.uiCanvas?.remove();\n\n    delete this.snake;\n    delete this.snakeCanvas;\n    delete this.grid;\n    delete this.gridCanvas;\n    delete this.food;\n    delete this.foodCanvas;\n    delete this.ui;\n    delete this.uiCanvas;\n\n    this.snake = null;\n    this.snakeCanvas = null;\n    this.grid = null;\n    this.gridCanvas = null;\n    this.food = null;\n    this.foodCanvas = null;\n    this.ui = null;\n    this.uiCanvas = null;\n\n    window.cancelAnimationFrame(this.rafId);\n  }\n\n  handleEvent(e: Event) {\n    switch (e.type) {\n      case EventTypes.KEYUP:\n        this.handleKeyup(e as KeyboardEvent);\n        break;\n    }\n  }\n\n  handleKeyup(e: KeyboardEvent) {\n    switch (e.code) {\n      case KeyCode.ENTER:\n        if (this.snake?.isSnakeDead()) {\n          this.gameCount++;\n          this.tearDown();\n          this.setUp();\n          this.run();\n          return;\n        }\n        this.paused = !this.paused;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  run(timestamp?: number) {\n    this.clear();\n\n    const score = this.food?.getEatCount() ?? 0;\n    this.ui?.setScore(score);\n\n    const snakeDead = this.snake?.isSnakeDead();\n\n    if (snakeDead) {\n      this.ui?.setGameOver(true);\n      this.ui?.draw(timestamp, this.paused);\n      return;\n    }\n\n    this.ui?.draw(timestamp, this.paused);\n    this.snake?.draw(timestamp, this.paused);\n    this.food?.draw();\n\n    const snakeCollision = this.snake?.getCollision();\n    const foodCollision = this.food?.getCollision();\n    const wallCollision = this.grid?.getCollision();\n\n    if (snakeCollision) {\n      foodCollision?.checkBounds([snakeCollision]);\n      wallCollision?.checkBounds([snakeCollision]);\n    }\n\n    this.rafId = window.requestAnimationFrame(this.run.bind(this));\n  }\n\n  public clear(): void {}\n}\n","import React, { useEffect } from \"react\";\nimport { GameController } from \"../GameController\";\n\nimport \"./App.css\";\n\nfunction App() {\n  useEffect(() => {\n    const gameController = GameController.create();\n    gameController.run();\n  }, []);\n  return <div id=\"board\"></div>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./demo/index.css\";\nimport App from \"./demo/App\";\nimport * as serviceWorker from \"./demo/serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}